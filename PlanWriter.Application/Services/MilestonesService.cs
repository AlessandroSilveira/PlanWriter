using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;
using PlanWriter.Application.Interfaces;
using PlanWriter.Domain.Dtos;
using PlanWriter.Domain.Entities;
using PlanWriter.Domain.Interfaces.Repositories;
using PlanWriter.Domain.Interfaces.Services;

namespace PlanWriter.Application.Services;

public class MilestonesService : IMilestonesService
{
    private readonly IMilestonesRepository repo;
    private readonly IProjectRepository projects;
    private readonly IUserService userService;

    public MilestonesService(
        IMilestonesRepository repo,
        IProjectRepository projects,
        IUserService userService)
    {
        this.repo = repo;
        this.projects = projects;
        this.userService = userService;
    }

    /* ===================== LIST ===================== */
    public async Task<IReadOnlyList<MilestoneDto>> GetProjectMilestonesAsync(Guid projectId, ClaimsPrincipal user, CancellationToken ct) 
    {
        var userId = userService.GetUserId(user);

        // garante ownership do projeto
        var project = await projects.GetUserProjectByIdAsync(projectId, userId)
                      ?? throw new UnauthorizedAccessException("Projeto não encontrado.");

        var items = await repo.GetByProjectIdAsync(projectId, ct);

        return items
            .OrderBy(m => m.Order)
            .Select(Map)
            .ToList();
    }

    /* ===================== CREATE ===================== */
    public async Task<MilestoneDto> CreateAsync(
        Guid projectId,
        ClaimsPrincipal user,
        CreateMilestoneDto dto,
        CancellationToken ct)
    {
        if (dto is null)
            throw new ArgumentNullException(nameof(dto));

        if (dto.TargetAmount <= 0)
            throw new ArgumentException("TargetAmount deve ser maior que zero.");

        var userId = userService.GetUserId(user);

        var project = await projects.GetUserProjectByIdAsync(projectId, userId)
                      ?? throw new UnauthorizedAccessException("Projeto não encontrado.");

        var order = dto.Order
                    ?? await repo.GetNextOrderAsync(projectId, ct);

        var milestone = new Milestone
        {
            Id = Guid.NewGuid(),
            ProjectId = projectId,
            Name = string.IsNullOrWhiteSpace(dto.Name)
                ? dto.TargetAmount.ToString("N0")
                : dto.Name.Trim(),

            TargetAmount = dto.TargetAmount,
            Order = order,
            DueDate = dto.DueDate,
            Notes = dto.Notes,

            AutoGenerated = false,
            Completed = false,
            CreatedAt = DateTime.UtcNow
        };

        milestone = await repo.AddAsync(milestone, ct);
        return Map(milestone);
    }

    /* ===================== DELETE ===================== */
    public async Task DeleteAsync(
        Guid milestoneId,
        ClaimsPrincipal user,
        CancellationToken ct)
    {
        var userId = userService.GetUserId(user);

        // NÃO validamos milestone diretamente
        // assumimos que o repo só deleta por ID
        // e que milestones SEMPRE pertencem a um projeto do usuário

        // alternativa segura: repo pode garantir ProjectId internamente
        await repo.DeleteAsync(milestoneId, Guid.Parse(userId),ct);
    }

    /* ===================== AUTO MILESTONES ===================== */
    public async Task EvaluateAutoMilestonesAsync(
        Guid projectId,
        int totalAccum,
        CancellationToken ct)
    {
        var project = await projects.GetByIdAsync(projectId);
        if (project == null || project.WordCountGoal.GetValueOrDefault() <= 0)
            return;

        var goal = project.WordCountGoal.Value;

        await TryCreateAuto(projectId, totalAccum, goal, 0.25, "25%", "Você começou com tudo!", ct);
        await TryCreateAuto(projectId, totalAccum, goal, 0.50, "50%", "Metade da jornada concluída!", ct);
        await TryCreateAuto(projectId, totalAccum, goal, 0.75, "75%", "Falta pouco!", ct);
        await TryCreateAuto(projectId, totalAccum, goal, 1.00, "100%", "Meta alcançada!", ct);
    }

    

    private async Task TryCreateAuto(
        Guid projectId,
        int totalAccum,
        int goal,
        double ratio,
        string name,
        string notes,
        CancellationToken ct)
    {
        if (totalAccum < goal * ratio) return;
        if (await repo.ExistsAsync(projectId, name, ct)) return;

        var order = await repo.GetNextOrderAsync(projectId, ct);

        var milestone = new Milestone
        {
            Id = Guid.NewGuid(),
            ProjectId = projectId,
            Name = name,
            TargetAmount = (int)(goal * ratio),
            Order = order,
            Notes = notes,
            AutoGenerated = true,
            Completed = true,
            CreatedAt = DateTime.UtcNow
        };

        await repo.AddAsync(milestone, ct);
    }
    
    public async Task EvaluateCompletionAsync(Guid projectId, int totalAccum, CancellationToken ct)
    {
        var milestones = await repo.GetByProjectIdAsync(projectId, ct);

        foreach (var m in milestones.Where(x => !x.Completed))
        {
            if (totalAccum >= m.TargetAmount)
            {
                m.Completed = true;
                m.CompletedAt = DateTime.UtcNow;

                await repo.UpdateAsync(m, ct);
            }
        }
    }

    public async Task EvaluateMilestonesAsync(Guid projectId, int totalAccum, CancellationToken ct)
{
    // 1️⃣ Busca projeto
    var project = await projects.GetProjectById(projectId);
    if (project == null || project.WordCountGoal <= 0)
        return;

    var goal = project.WordCountGoal.Value;

    // 2️⃣ Busca milestones existentes
    var milestones = await repo.GetByProjectIdAsync(projectId, ct);

    /* =========================================================
     * 3️⃣ MARCAR milestones (manuais + automáticos) como concluídos
     * ========================================================= */
    foreach (var m in milestones.Where(m => !m.Completed))
    {
        if (totalAccum >= m.TargetAmount)
        {
            m.Completed = true;
            m.CompletedAt = DateTime.UtcNow;

            await repo.UpdateAsync(m, ct);
        }
    }

    /* =========================================================
     * 4️⃣ GARANTIR milestones automáticos
     * ========================================================= */
    var autoMilestones = new[]
    {
        new { Percent = 0.25, Name = "25%", Order = 100 },
        new { Percent = 0.50, Name = "50%", Order = 200 },
        new { Percent = 0.75, Name = "75%", Order = 300 },
        new { Percent = 1.00, Name = "100%", Order = 400 }
    };

    foreach (var auto in autoMilestones)
    {
        var target = (int)Math.Round(goal * auto.Percent);

        // evita duplicação
        var exists = milestones.Any(m =>
            m.AutoGenerated &&
            m.Name == auto.Name);

        if (exists)
            continue;

        var milestone = new Milestone
        {
            Id = Guid.NewGuid(),
            ProjectId = projectId,
            Name = auto.Name,
            TargetAmount = target,
            Order = auto.Order,
            AutoGenerated = true,
            Completed = totalAccum >= target,
            CompletedAt = totalAccum >= target ? DateTime.UtcNow : null,
            CreatedAt = DateTime.UtcNow
        };

        await repo.AddAsync(milestone, ct);
    }
}


    /* ===================== MAP ===================== */
    private static MilestoneDto Map(Milestone m) =>
        new()
        {
            Id = m.Id,
            ProjectId = m.ProjectId,
            Name = m.Name,
            TargetAmount = m.TargetAmount,
            Order = m.Order,
            DueDate = m.DueDate,
            Notes = m.Notes,
            AutoGenerated = m.AutoGenerated,
            Completed = m.Completed,
            CreatedAt = m.CreatedAt
        };
}
